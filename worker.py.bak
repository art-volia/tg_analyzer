# worker.py — полная исправленная версия с таймзоной Europe/Bucharest

import asyncio
import os
import yaml
import random
from datetime import datetime
from zoneinfo import ZoneInfo

from dotenv import load_dotenv
from telethon import TelegramClient, errors
from telethon.tl.functions.messages import GetHistoryRequest
from telethon.tl.types import User as TLUser, Channel, Chat as TLChat

from db import (
    get_session, Account, User, Chat, Message, Cursor, Window,
    AccountChat, ChatBot, DirectPeer
)
from utils import setup_logger, sleep_range, jitter_ms

# --- таймзона Бухареста ---
BUCHAREST_TZ = ZoneInfo("Europe/Bucharest")

load_dotenv()
API_ID = int(os.getenv("API_ID"))
API_HASH = os.getenv("API_HASH")
SESSION_NAME = os.getenv("SESSION_NAME", "research_account")

with open("config.yaml", "r", encoding="utf-8") as f:
    CFG = yaml.safe_load(f)

DB_PATH = CFG["storage"]["db_path"]
LOG_PATH = CFG["storage"]["log_path"]
logger = setup_logger(LOG_PATH)

BATCH_MIN, BATCH_MAX = CFG["limits"]["batch_size_range"]
PBATCH = CFG["limits"]["pause_between_batches_sec"]
PCHAT  = CFG["limits"]["pause_between_chats_sec"]
MICRO_N = CFG["limits"]["micro_pause_every_n_msgs"]
MICRO_MS = CFG["limits"]["micro_pause_ms"]
USE_TAKEOUT = CFG["behavior"].get("use_takeout_for_bulk_exports", True)
INCLUDE_DIALOGS = CFG["behavior"].get("include_dialogs", False)


def get_or_create_account(sess):
    # NOTE: важно, чтобы get_session в db.py создавал Session(..., expire_on_commit=False)
    res = sess.exec(Account.select().where(Account.session_name == SESSION_NAME)).first() if hasattr(Account, 'select') else None
    if not res:
        res = Account(
            session_name=SESSION_NAME,
            display_name=SESSION_NAME,
            created_at=datetime.now(BUCHAREST_TZ).isoformat()
        )
        sess.add(res)
        sess.commit()
    return res


async def save_messages(sess, entity, msgs, account_id: int):
    chat_id = entity.id
    total = 0
    for idx, m in enumerate(msgs):
        sender = await m.get_sender()
        uid = None
        if isinstance(sender, TLUser):
            uid = sender.id
            u = sess.get(User, uid)
            if not u:
                sess.add(User(
                    user_id=uid,
                    username=sender.username,
                    first_name=sender.first_name,
                    last_name=sender.last_name,
                    is_bot=bool(sender.bot)
                ))
            else:
                if u.is_bot is None and sender.bot is not None:
                    u.is_bot = bool(sender.bot)
                    sess.add(u)
            if sender.bot:
                sess.merge(ChatBot(chat_id=chat_id, bot_user_id=uid))

        # m.date у Telethon — это aware datetime (UTC). Приводим к Бухаресту:
        msg_dt_local = m.date.astimezone(BUCHAREST_TZ).isoformat()

        sess.merge(Message(
            chat_id=chat_id,
            message_id=m.id,
            account_id=account_id,
            user_id=uid,
            date=msg_dt_local,
            text=(m.message or "").strip()
        ))
        total += 1

        # микропаузa для рандомизации паттерна
        if MICRO_N and isinstance(MICRO_N, list):
            lo, hi = MICRO_N
            if lo <= (idx + 1) % random.randint(lo, hi) <= hi:
                jitter_ms(*MICRO_MS)

    sess.commit()
    return total


async def ensure_chat_record(sess, entity, account_id: int):
    ch = sess.get(Chat, entity.id)
    if not ch:
        is_group = isinstance(entity, (TLChat,)) or (hasattr(entity, 'megagroup') and entity.megagroup)
        is_channel = isinstance(entity, Channel) and not (getattr(entity, 'megagroup', False))
        ch = Chat(
            chat_id=entity.id,
            title=getattr(entity, "title", None),
            type=str(type(entity)).split("'")[1],
            is_group=bool(is_group),
            is_channel=bool(is_channel)
        )
        sess.add(ch)
        sess.commit()
    sess.merge(AccountChat(account_id=account_id, chat_id=entity.id))
    sess.commit()


async def fetch_incremental(client, entity, sess, account_id: int):
    cur = sess.get(Cursor, entity.id)
    if not cur:
        cur = Cursor(chat_id=entity.id, oldest_fetched_id=0, newest_fetched_id=0)
        sess.add(cur)
        sess.commit()

    min_id = cur.newest_fetched_id or 0
    got = 0
    while True:
        limit = random.randint(BATCH_MIN, BATCH_MAX)
        try:
            hist = await client(GetHistoryRequest(
                peer=entity, offset_id=min_id, add_offset=0,
                limit=limit, max_id=0, min_id=min_id, hash=0
            ))
        except errors.FloodWaitError as e:
            logger.warning(f"FLOOD_WAIT {e.seconds}s on incremental; sleeping")
            await asyncio.sleep(e.seconds + 5)
            continue

        msgs = hist.messages
        if not msgs:
            break

        got += await save_messages(sess, entity, msgs, account_id)
        cur.newest_fetched_id = max(cur.newest_fetched_id, max(m.id for m in msgs))
        sess.add(cur)
        sess.commit()
        sleep_range(*PBATCH)

    if got:
        logger.info(f"[{entity.id}] incremental saved {got}")
    return got


async def fetch_backfill(client, entity, sess, account_id: int, window=None):
    chat_id = entity.id
    cur = sess.get(Cursor, chat_id)
    if not cur:
        cur = Cursor(chat_id=chat_id, oldest_fetched_id=0, newest_fetched_id=0)
        sess.add(cur)
        sess.commit()

    offset_id = cur.oldest_fetched_id or 0
    max_id = window.max_id if window and window.max_id else 0

    total = 0
    while True:
        limit = random.randint(BATCH_MIN, BATCH_MAX)
        try:
            hist = await client(GetHistoryRequest(
                peer=entity, offset_id=offset_id, add_offset=0,
                limit=limit, max_id=max_id, min_id=0, hash=0
            ))
        except errors.FloodWaitError as e:
            logger.warning(f"FLOOD_WAIT {e.seconds}s on backfill; sleeping")
            await asyncio.sleep(e.seconds + 5)
            continue

        msgs = hist.messages
        if not msgs:
            break

        total += await save_messages(sess, entity, msgs, account_id)
        new_oldest = min(m.id for m in msgs)

        if cur.oldest_fetched_id == 0 or new_oldest < cur.oldest_fetched_id:
            cur.oldest_fetched_id = new_oldest
        if cur.newest_fetched_id == 0:
            cur.newest_fetched_id = max(m.id for m in msgs)

        sess.add(cur)
        sess.commit()

        offset_id = new_oldest
        sleep_range(*PBATCH)

    if total:
        logger.info(f"[{entity.id}] backfill saved {total}")
    return total


async def scan_directs(client, sess, account_id: int):
    if not INCLUDE_DIALOGS:
        return 0
    count = 0
    async for dlg in client.iter_dialogs():
        ent = dlg.entity
        if isinstance(ent, TLUser):
            sess.merge(DirectPeer(account_id=account_id, user_id=ent.id))
            u = sess.get(User, ent.id)
            if not u:
                sess.add(User(
                    user_id=ent.id,
                    username=ent.username,
                    first_name=ent.first_name,
                    last_name=ent.last_name,
                    is_bot=bool(ent.bot)
                ))
            count += 1
    sess.commit()
    if count:
        logger.info(f"Direct peers discovered: {count}")
    return count


async def process_chat(client, chat_ref, account_id: int):
    entity = await client.get_entity(chat_ref)
    with get_session(DB_PATH) as sess:
        await ensure_chat_record(sess, entity, account_id)
        await fetch_incremental(client, entity, sess, account_id)
        await fetch_backfill(client, entity, sess, account_id)


async def main():
    chats = CFG["chats"]
    async with TelegramClient(SESSION_NAME, API_ID, API_HASH) as client_ctx:
        # создаём/получаем аккаунт и сразу сохраняем его id
        with get_session(DB_PATH) as sess:
            acc = get_or_create_account(sess)
            acc_id = acc.id

        if USE_TAKEOUT:
            # takeout режим (bulk)
            async with client_ctx.takeout() as client:
                await scan_directs(client, get_session(DB_PATH), acc_id)
                for c in chats:
                    await process_chat(client, c, acc_id)
                    sleep_range(*PCHAT)
        else:
            # обычный режим
            await scan_directs(client_ctx, get_session(DB_PATH), acc_id)
            for c in chats:
                await process_chat(client_ctx, c, acc_id)
                sleep_range(*PCHAT)


if __name__ == "__main__":
    asyncio.run(main())
